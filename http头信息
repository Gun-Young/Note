http 请求头：

1.Authorization  HTTP授权的授权证书   

2.Cache-Control  指定请求和响应遵循的缓存机制   Cache-Control:no-cache

3.Connection     表示是否需要持久连接(http 1.1默认进行持久连接)  Connection:close


4.If-Modified-Since &  Last-Modified
  
  客户端浏览器都有缓存的，里面存放之前访问过的一些网页文件，和服务器发过来的改文件的最后服务器修改的时间。
  
  在发送http请求时，把浏览器端缓存页面的最后修改时间一起发送到服务器，服务器会把这个时间与服务器实际文件的最后修改时间进行对比
  
  如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接收到之后，就直接把本地缓存的文件显示到浏览器中。
  
  如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接收到之后，会丢弃旧文件按，把新文件缓存起来，并显示到浏览器中。
  

  
5.If-None-Match & Etag
  
  它的原理是这样的，当浏览器请求服务器的某项资源(A)时, 服务器根据A算出一个哈希值(3f80f-1b6-3e1cb03b)并通过 ETag 返回给浏览器，
  
  浏览器把"3f80f-1b6-3e1cb03b" 和 A 同时缓存在本地，当下次再次向服务器请求A时，会通过类似 If-None-Match: "3f80f-1b6-3e1cb03b" 的请求头把ETag发送给服务器，
  
  服务器再次计算A的哈希值并和浏览器返回的值做比较，如果发现A发生了变化就把A返回给浏览器(200)，如果发现A没有变化就给浏览器返回一个304未修改。
  
  这样通过控制浏览器端的缓存，可以节省服务器的带宽，因为服务器不需要每次都把全量数据返回给客户端。
  
  
  
  
6.If-Modified-Since & Last-Modified 对比 If-None-Match & Etag
  
     Last-Modified与Etag类似。不过Last-Modified表示响应资源在服务器最后修改时间而已。与Etag相比，不足为：

　　（1）Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间；

　　（2）如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存；

　　（3）有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形。

    然而，Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。
 

7.Referer  

  当浏览器向web服务器发送请求的时候，一般会带上Referer,告诉服务器我是从哪个页面链接过来的，服务器由此可以获得一些信息用于处理。
  
  
  
 

 
响应头部分：

1.Allow:  对某网络资源的有效请求行为，不允许则返回405  Allow：GET,HEAD

2.Cache-Control:  告诉所有的缓存机制是否可以缓存以及那种类型

3.Etag:  请求变量的实体标签的当前值

4.Expires:响应过期日期和时间

5.Last-Modified: 请求资源的最后过期时间

6.Location:用来重定向接收方到非请求URL的位置来完成请求或标识新的资源


  
 
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
