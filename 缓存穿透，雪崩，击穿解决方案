一.缓存穿透：
   是指查询一个数据库一定不存在的值。正常的使用缓存流程大致是，数据查询先查询缓存，如果key不存在或者已经过期
   再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询的对象为空，则不进行缓存。
   
   代码流程：
   1.参数传入对象主键Id
   2.根据key从缓存中获取对象
   3.如果对象不为空，直接返回
   4.如果对象为空，进行数据库查询
   5.如果从数据库查询出的对象不为空，则放入缓存，并设定过期时间
   
   如果传入的参数都是缓存中一定不存在的，那么每次就会查询数据库，而每次查询数据库都是空，
   每次又都不会进行缓存。假如又恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。
   
   解决办法： 即使数据库查询不到数据，也进行缓存，key-null,同时设置很短的过期时间。
   
   
   
   
 二.缓存雪崩
    是指再某一时间段，缓存集中过期失效。
	假如一批商品，集中放入缓存，并设定缓存一小时，那么到了一小时之后，这批商品的缓存就都过期了，
	而对这波商品的访问查询，都落在了数据库上，对数据库而言，就会产生周期性压力波峰，如果流量很大，
	就会压垮数据库。
	
	解决办法： 再设置过期时间，加一个随机银子，尽可能分散缓存过期时间，而且，热数据缓存的时间要长一些，
	冷数据缓存时间短一些，也能缓存服务的资源。
	
	
	
	
	
	
三.缓存击穿
     缓存击穿是指缓存中没有但数据库中有数据（一般缓存时间到期），这是由于并发量特别大，同时读缓存没有
	 读取到数据，又同时取数据库查询数据，引起数据库压力瞬间增大，造成压力过大。
	 
	 解决方法：
	 1. 设置热点数不过期
	 2.加互斥锁
	 伪代码如下：
	 
	 public static String getData(String key) {
	      //1.从缓存中获取数据
		  String result = getDataFromRedis(key)；
		  //2.缓存中不存在数据
		  if(result == null){
		       //获取锁,获取成功，去数据库查询
			   if(reenLock.tryLock()){
			          //从数据库获取数据
					  result = getDataFromMysql(key);
					  //更新缓存
					  if(result != null){
					      setDataToCache(key,reuslt);
					  }
					  //释放锁
					  reenLock.unlock();
			   }else{
			       //获取锁失败，暂停100ms,重新去获取
				   Thread.sleep(100);
				   result = getDate(key);
			   }
			  
		  }
		  return result;
	 }




