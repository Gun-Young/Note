网络相关
文章地址： https://mp.weixin.qq.com/s/ftkXl-45gKWY3DfjQvKywQ
假设有A,B,C,D,E五台电脑，A的mac地址为aa-aa-aa-aa-aa-aa-aa,B的mac地址为bb-bb-bb-bb-bb-bb-bb,以此类推
应用层 --- 表示层 --- 会话层 --- 传输层 --- 网络层 --- 数据链路层 --- 物理层
                                            路由器       交换机       集线器 


1. 集线器
  集线器将电信号无脑转发到所有出口（广播），不做任何处理，工作在物理层。
  A发送一个请求给集线器，集线器会无脑转发给所有的出口，BCDE怎么知道数据包是不是发送给自己的。
  A在发送数据包给B时，只要在头部拼接一个源mac:aa-aa-aa-aa-aa-aa  目标mac:bb-bb-bb-bb-bb-bb,
  B在收到数据包之后，根据头部目标mac地址信息，判断这个数据包的确是发给自己的，于是便收下，
  其他的CDE收到数据包之后，根据头部的目标mac地址信息，判断这个数据包并不是发给自己的，于是便丢弃
  
  集线器会把发给B的消息广播给所有连接到集线器中的所有电脑，这样既不安全，又不节省网络资源
  
  
2. 交换机
  交换机比集线器智能一些，只发给目标MAC地址指向的那台电脑，工作在数据链路层。
  交换机内部维护一个MAC地址表，记录这每个MAC地址的设备，连接在哪个端口上。
  
  假如mac地址表是空的，是怎么逐步建立起来的，假如Mac地址表是空的，A给B发送了数据，头部数据为：源mac:aa-aa-aa-aa-aa-aa  目标mac:bb-bb-bb-bb-bb-bb,
  由于这个数据包从端口4进入的交换机，所以此时交换机就可以在MAC地址表记录第一条数据：mac:aa-aa-aa-aa-aa-aa  端口：4
  交换机看目标mac:bb-bb-bb-bb-bb-bb 在地址表中并没有映射关系，于是将此包发给了所有端口，也即发给了所有机器。之后，只有机器B确实是发给自己的
  包，于是做出响应，响应数据从端口1进入交换机，于是交换机此时在地址表中更新了第二条数据： 源mac: bb-bb-bb-bb-bb-bb 端口：1，
  经过该网络中的机器不断的通信，交换机最终将mac地址表建立完毕。
  
  
  
  
3.路由器
  拥有自己独立的mac地址，而且同时还能把数据包做一次转发，它工作的网络层。（路由器的每个端口，都有独立的mac地址）
  
  对于电脑A来说，A只能直接把包发给处于一个子网下的某个IP上，所以发给路由器还是发给某个电脑，对于A来说并不关心，只要这个
  设备有个IP地址就行。默认网关，就是A在自己电脑里配置的一个IP地址，以便在发给不同子网的机器时，发给这个IP地址。
  
  假设A,C不在同一子网，A要发送请求给C，ip与子网掩码进行计算，发现A，C不在同一子网，交换机1根据MAC地址表发送数据到
  路由器对应的端口。路由器收到数据包，根据路由表，查询到网段对应的端口，将数据发给交换交换机2，arp缓存表记录着ip与mac地址的
  对应关系。
  一开始的时候这个表是空的，电脑A为了知道电脑B的MAC地址，将会广播一条arp请求，B收到请求后，带上自己的MAC地址给A一个响应，此时A便
  更新了自己的arp表，这样通过大家不断广播arp请求，最终所有电脑里面都将arp缓存表更新完整。
  
  
  
  
  


----各个视角工作过程-----

电脑视角： 
  *** 首先我要知道我的IP以及对方的IP
  *** 通过子网掩码判断我们是不是在同一子网
  *** 在同一子网就通过arp获取对方mac地址直接扔出去
  *** 不在同一个子网就通过arp获取默认网关的mac地址直接扔出去
  
 
交换机视角：
  *** 我收到的数据包必须有目标mac地址
  *** 通过mac地址查询映射关系
  *** 查到了就按照映射关系从我的指定端口发送出去
  *** 查不到就所有端口广播出去（收到响应，丰富自己mac地址表）
  
  

路由器视角：
  *** 我收到数据包必须有目标ip地址
  *** 通过路由表查询映射关系
  *** 查到了就按映射关系从我的指定端口发出去（不在任何一个子网范围，走其路由器的默认网关也是查到了）
  *** 查不到则返回一个路由不可达的数据包
  



-------------------------

  
  
  
  
  
  
涉及的表:
*** 交换机中有mac地址表用于映射MAC地址和它的端口
*** 路由器中有路由表用于映射IP地址（段）和他的端口
*** 电脑和路由器中都有arp缓存表用于缓存IP和MAC地址的映射关系  
  
  
  
  
  
  
  
 ---------------------------
1. 物理层：字面解释就是物理传输，硬件，物理特性，中间的物理连接可以是光缆，电缆，双绞线，无线电波等，传输的是010101010这些二进制位
2. 数据链路层： 数据链路层就是对电信号来做分组的，统一的标准，以太网协议，Ethernet规定：一组电信号称之为一个数据包，或者叫做一个帧。
   每一数据帧分为：报头head和数据data两部分
   head包含：源地址，目标地址，数据类型 
   data包含：数据包的具体内容
  （局域网的理解：什么是互联网，互联网就是由一个个局域网组成，数据链路层的工作方式 --- 广播）
   局域网内的计算机通信都广播。广播出去以后，所有人都听的见，所有人都会拆开这个包，读取发送者是谁，接收者是谁，只要接收者不是自己
   就丢弃掉。   
3.网络层： 
    假如局域网1中的pc1要与局域网2中的pc2进行通信，这就是跨网络通信，数据链路层就解决不了这个问题了，需要网络层。
     mac地址是标识电脑的唯一地址，ip地址用来标识你是在哪个局域网。
	 数据链路层中会把网络层的数据包封装到数据链路层的data位置，然后再添加上自己的head，再发给物理层，物理层发给网关，
	 网关再发发出去。


4.传输层：
   传输层的由来：网络层的ip帮我们区分子网，以太网层的mac帮我们找到主机，通过ip和mac地址找到了一台特定的主机，如何标识这台主机上的应用程序，
   答案就是端口，端口即应用程序与网卡关联的编号。 传输层功能，建立端口到端口的通信。端口范围0-65535，其中0，1023为系统占用端口
   tcp协议：可靠传输，TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，
   以确保单个TCP数据包不必再分割。
   以太网头  ip头  tcp头 数据 
   
   udp协议：
   不可靠传输，报头部分一共只有8个字节，总长度不超过65535字节，正好放进一个IP数据包
   以太网头  ip头  udp头 数据 
   
   
5.应用层：
   应用层由来，用户使用的都是应用程序，均工作于应用层，互联网是开发，大家都是应用程






-- ----------------------------


HTTPS交互过程

1. 客户端请求建立SSL连接，并将自己支持的一套加密规则发送给网站
2. 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器，证书里包含了网站地址，加密公钥，
   以及证书的颁发机构等信息
   
3. 获得网站证书之后浏览器要做的工作：
   a.验证证书的合法性
   b.如果证书受信任，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密
   c.使用约定好的HASH计算握手信息
   d.使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站
   
4. 网站接收浏览器发来的数据之后要做以下操作：
   a. 使用自己的私钥将信息解密取出密码
   b. 使用密码解密浏览器发来的握手信息，并验证hash是否以浏览器发来的一致
   c. 使用密码加密一段握手消息，发送给浏览器
   
5. 浏览器解密并计算握手消息的hash,如果与服务端发来的Hash一致，此时握手结束

6. 使用随机密码和对称加密算法对传输的数据加密码，传输 

  非对称加密算法---用于再握手过程中加密生成的密码
  对称加密算法: 用于对真正传输的数据进行加密 
  HASH算法： 验证数据的完整性



-----------------------------------------------
HTTP代理：

1. 普通代理
   这种代理扮演的是中间人的角色，对于连接到它的客户端来说，它是服务端，对于要连接的服务端来说，它就是客户端。它就负在两端之间来回传授那个HTTP报文。
   HTTP客户端向代理发送请求报文，代理服务器需要正确地处理请求和连接,同时向服务器发送请求，并将收到的响应转发给客户端。
   
   正向代理：代理的客户端，服务端不知道实际发起请求的客户端
   反向代理：代理的服务端，客户端不知道实际提供提供服务的服务端
 
2.隧道代理

  HTTP客户端通过CONNECT方法请求隧道代理创建按一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。
  假如通过代理访问A网站，浏览器首先通过CONNECT请求，让代理创建一条到A网站的TCP连接，一旦TCP连接建好，代理无脑转发后续的流量就好，
  所以这种代理，理论上适用于任意基于TCP的应用层协议，HTTPS网站使用的TLS协议当然也可以。 这也是这种dialing为什么被称为隧道的原因。
  对于HTTPS来说，客户端透过代理直接跟服务端进行TLS握手协商密钥，所以依然是安全的。
  （a）浏览器发送CONNECT请求到代理服务器
      CONNECT test.com:443 HTTP/1.0
	  
   (b) 代理服务器收到CONNECT请求，打开到目标服务器的443端口TCP连接
   (c) 目标服务器给代理服务器返回连接成功
  （d）代理服务器给浏览器返回HTTP连接就绪报文
   (e) 此时，建立起了原始数据的任意，双向通信
  
   
   


--------------------------------------------------------------------------------
https交互消息过程

1. https是建立在TCP之上的，需要进行三次握手
2. 客户端首先发起client hello消息，包含一个客户端随机生成的random1数字，客户端支持的加密算法，以及SSL信息
3. 服务器收到客户端的client hello消息以后，取出客户端发来的random1数字，并且取出客户端发来的支持的加密算法
   然后选出一个加密算法，并生成一个随机数random2,发送给客户端server hello,让客户端对服务器进行身份验证，
   服务端通过将自己的公钥通过数字证书的方式发送给客户端
4. 客户端收到服务端传来的证书后，先从CA验证该证书的合法性 ，验证通过后，取出证书中的服务端公钥，再生成一个
   随机数random3,再用服务端公钥非对称加密random3生成PreMaster Key，并将PreMaster Key发送到服务端。
5.服务端通过私钥将PreMaster Key解密获取到random3,此时客户端和服务器都持有三个随机数，random1,2,3,双方再通过
  这三个随机数经过相同的算法生成一个密钥，而后应用成传输的数据都使用这套密钥进行加密，
  
6.最后ApplicationData全部使用对称加密的原因就是因为非对称加密太卡，对称加密不影响性能。所以实际上也看的出来，Https
  的真正目的就是保证对称加密的密钥不被破解，不被替换，不被中间人攻击。





----------------------------------------------------------------

安全通信三个原则

1. 数据的内容加密
   敏感信息要加密，明文传输等于自杀
   
2. 通信双方的身份校验
   我们的数据包不是从A直接到B的，中间要经过多次的路由转发，这个中间一旦有人截获了我们的数据包，换成自己的数据包就很危险了。
   所以我们需要一种禁止能校验通讯双方的身份。确保我们通讯双方的身份。
   
3.数据内容的完整性
  按道理TCP能保证数据有序完整的到达对方，但是中间我们经过多次的路由器转发，可能被劫持，被劫持以后可能会对数据包进行篡改，
  这时候我们需要一种机制保护我们的数据不被篡改，即使被篡改也能被我们察觉。





-------------------------------------------------------------------
加密方式：

1. 对称加密 
   采用单钥密码系统的加密方法，同一个密钥可以同时用做信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。
   需要对加密和解密使用相同密钥的加密算法，由于其速度快，对称性加密通常在消息发送方需要加密大量数据时使用。
   加密的安全性不仅取决于加密算法本身，密钥管理的安全性更重要，因为加密和解密使用同一个密钥，如何把密钥安全的
   传递到解密者手中就成了必须要解决的问题。
   常用算法： DES,3DES,AES,Blowfish
   
   
2. 非对称加密 
   加密使用的密钥和解密使用的密钥是不同的，分别称为公钥，私钥，公钥和算法都是公开的，私钥是保密的，相比较于非对称算法性能低，但是安全性超强
   常用算法： RSA,DSA,ECDSA,DH等
   
   
3. hash算法 
   将任意长度的信息转换成较短的固定长度的值，通常其长度要比信息小的多，且算法不可逆
   常用算法： MD5,SHA-1,SHA-2,SHA-256
   
4. 数字签名
   数字签名技术是将摘要信息（hash算法计算出固定长度）用发送者的私钥加密，与原文一起传送给接收者。接收者只用发送者的公钥才能解密被
   加密的摘要信息，然后用hash函数对收到的原文产生一个摘要信息，与解密的摘要信息对比，如果相同，则说明收到信息是完整的，在传输的
   过程中没有被修改，因此数字签名能够验证信息的完整性。
   
     
   

-----------------------------------------------------------------------------


SSL握手过程：
1. client hello 
   客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段等信息
   
2.server_hello + server_certificate + server_hello_done 
	  *** server hello: 服务端返回协商的信息结果，包括选择使用的协议版本version,选择的加密套件cipher suite,选择的压缩算法
		   compression method,随机数random
	  *** server certificate: 服务器端对应的证书链，用于身份验证与密钥交换
	  *** server hello done: 通知客户端server hello信息发送结束
     
3. 证书校验
   客户端验证证书的合法性，如果验证通过才会进行后续通信，合法性验证包括如下：
   *** 证书链的可信性
   *** 证书是否吊销
   *** 有效期expiry date，证书是否在有效时间范围
   *** 域名domain,核查证书域名是否与当前的访问域名匹配


4. client_key_exchange +change_ciper_spec+encrypted_handshake_message
   *** client_key_exchange: 合法性验证通过后，客户端计算产生随机数字pre-master，并用证书公钥加密，发给服务器端
   *** 此时客户端已经获取全部计算协商密钥需要的信息，两个明文随机数random_c和  random_s 与自己计算产生的pre-master，计算得到协商密钥:
       enc_key =fuc(random_c,random_s,pre-master)
   *** change_ciper_spec：客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信
   *** encrypted_handshake_message: 结合之前所有通信参数的hash值与其他相关信息生成一段数据，采用协商的session_secret与算法进行加密，然后发送给
       服务器用于数据与握手验证


5. change_ciper_spec + encrypted_handshake_message 
   *** 服务器用私钥解密加密的pre-master数据，基于之前交换的两个明文随机数random_c和random_s,计算得到协商密钥：
       enc_key = fuc(random_c,random_s,pre-master)
   *** 计算之前所有接收信息的hash值，然后解密客户端发送的encryted_handshake_messge,验证数据和密钥的正确性
   *** change_ciper_spec: 验证通过之后，服务器同样发送change_cipher_spec以告知客户端的通信都采用协商的密钥与算法进行加密通信
   *** encrypted_handshake_message: 服务器结合所有当前的通信参数信息生成一段数据并采用协商密钥session secret与算法进行加密并发送到客户端。


6. 握手结束：
   客户端计算所有接收信息的hash值，并采用协商密钥解密encryted_handshake_messge,验证服务器发送的数据和密钥，验证通过则握手完成。
   
   
7. 加密通信
   开始使用协商密钥与算法进行加密通信。

参考文章； https://www.cnblogs.com/huanxiyun/articles/6554085.html











































































































  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
