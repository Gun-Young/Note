各种分布式式锁实实现思路：


一. 基于数据库悲观锁
    有事务加对数据加写锁的时候，其他是个不能加任何锁，保证同时只能一个线程在写数据
	优点：简单安全
	缺点：在高并发场景下，效率不高，容易出现数据库卡死情况
	


二.基于redis（满足CAP中的AP）
   redis提供了setnx原子操作，基于redis的分布式锁也是基于这个操作实现的。
   
   优点：性能高
   缺点：无一致性算法，从redis主从架构上考虑，存在问题，因为redis集群数据同步到各个节点是
     异步的，如果在Master上获取锁后，在没有同步到其他节点时，master节点崩溃了，此时新的master没有
	 数据，依然可以获取锁，所以多个应用服务又可能同时获取锁
   
   执行过程：
   1.机器A执行setnx加一个锁k,v,并加上过期时间，master更新了锁k的值
   2.此时master宕机，选举出的新的master,新的master数据没有机器A加的锁（数据没同步过来）
   3.此时机器B执行setnx加一个锁k,v2,出现重复加锁，两个线程拿到了同一个锁
   
   可以优化第3步，在执行访问共享数据前，再判断内存中的锁k的v值和redis中k的v值是都相同，如果不相同说明
   有线程修改了锁，加锁失败。
   
    1、机器A执行setNx了一个锁key，value为当前时间加上过期时间，master更新了锁key的值；
	2、此时，master宕机，选举出新的master，新的master正同步数据；
	3、机器B执行setNx了一个锁key，value为此时的时间加上过期时间；
	4、当机器A再次判断内存存储的锁与此时的锁key的值不一样时，机器A加锁失败；
	5、当机器B再次判断内存存储的锁与此时的锁key的值一样，机器B加锁成功。
	
	
	适用场景：
	如果为了效率而适用分布式锁，且偶尔允许失败，可以使用单节点redis分布式锁；如果为了正确性而使用分布式锁，
	最好再次检查redis分布式锁，虽然性能降低了，但是正确率更高
	
	现有框架： Redisson,spring-integration-redis
	
	
	
	
	
	
三.基于zookeeper实现分布式锁
   
   优点：稳定性好，ZAB一致性算法实现
   缺点：效率比redis低一些
   框架：Apache Curator
   
   原理： zookeeper是一种提供分布式服务协调的中心化服务，是以Paxos算法为基础实现的。
              zookeeper数据节点和文件目录类似，同时具有watch机制，基于这两个特性，得以实现分布式锁功能。
   
   数据节点： 
		         zookeeper提供一个多层级的节点命名空间(节点称为Znode)，每个节点都是用一个以斜杠（/）分隔的路径来表示，
		   除根几点外，每个节点都有父节点，非常类似于文件系统。
		         节点类型可以分为持久节点(persistent),临时节点(ephemeral)，每个节点还能被白哦及为有序性(sequential)，
		   一旦节点被标记为有序性，那么整个节点就具有顺序自增的特点 。
		          一般我们可以组合这几类节点来创建我们所需要的节点，比如，创建一个持久节点作为父节点，在父节点下面
		   创建临时节点，并标记该临时节点为有序性。
	
	watch机制：
                zookeeper还提供了另外一种重要的特性，watch(事件监听器)
				允许用户在指定节点上注册一些watch,并且在一些特定事件触发的时候，zookeeper服务端将事件通知给用户。
   
	
	执行过程：
	               我们需要建立一个父节点，节点类型为持久节点（PERSISTENT）中的 /locks/lock_name1 节点 ，
		   每当需要访问共享资源时，就会在父节点下建立相应的顺序子节点，节点类型为临时节点（EPHEMERAL），
		   且标记为有序性（SEQUENTIAL），并且以临时节点名称 + 父节点名称 + 顺序号组成特定的名字，
		   如 /0000000001 /0000000002 /0000000003 作为临时有序节点。
                  在建立子节点后，对父节点下面的所有以临时节点名称 name 开头的子节点进行排序，判断刚刚建立的
		  子节点顺序号是否是最小的节点，如果是最小节点，则获得锁。如果不是最小节点，则阻塞等待锁，并且获得
		  该节点的上一顺序节点，为其注册监听事件，等待节点对应的操作获得锁。当调用完共享资源后，删除该节点，
		  关闭 zk，进而可以触发监听事件，释放该锁。
	
	
	
	

四： 比较
1.对于Redis实现的分布式锁：
       大部分需求下，不会遇到「极端复杂场景」，基于Redis实现分布式锁很常用，性能也高。
      它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。
      另外来说的话，redis的设计定位决定了它的数据并不是强一致性的，没有一致性算法，在某些极端情况下，可能会出现问题，锁的模型不够健壮。
      即便有了Redlock算法的实现，但存在争议，某些复杂场景下，也无法保证其实现完全没有问题，并且也是比较消耗性能的。


2.对于Zookeeper实现的分布式锁:
    Zookeeper优点：
        天生设计定位是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。
        如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。
        如果客户端宕机，也没关系，临时节点会自动删除，触发监听器通知下一个节点。

    Zookeeper缺点：
       若有大量的客户端频繁的申请加锁、释放锁，对于ZK集群的压力会比较大。

	
	
	
	
	
	
	
	
