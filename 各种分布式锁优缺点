各种分布式式锁实实现思路：


一. 基于数据库悲观锁
    有事务加对数据加写锁的时候，其他是个不能加任何锁，保证同时只能一个线程在写数据
	优点：简单安全
	缺点：在高并发场景下，效率不高，容易出现数据库卡死情况
	


二.基于redis（满足CAP中的AP）
   redis提供了setnx原子操作，基于redis的分布式锁也是基于这个操作实现的。
   
   优点：性能高
   缺点：无一致性算法，从redis主从架构上考虑，存在问题，因为redis集群数据同步到各个节点是
     异步的，如果在Master上获取锁后，在没有同步到其他节点时，master节点崩溃了，此时新的master没有
	 数据，依然可以获取锁，所以多个应用服务又可能同时获取锁
   
   执行过程：
   1.机器A执行setnx加一个锁k,v,并加上过期时间，master更新了锁k的值
   2.此时master宕机，选举出的新的master,新的master数据没有机器A加的锁（数据没同步过来）
   3.此时机器B执行setnx加一个锁k,v2,出现重复加锁，两个线程拿到了同一个锁
   
   可以优化第3步，在执行访问共享数据前，再判断内存中的锁k的v值和redis中k的v值是都相同，如果不相同说明
   有线程修改了锁，加锁失败。
   
    1、机器A执行setNx了一个锁key，value为当前时间加上过期时间，master更新了锁key的值；
	2、此时，master宕机，选举出新的master，新的master正同步数据；
	3、机器B执行setNx了一个锁key，value为此时的时间加上过期时间；
	4、当机器A再次判断内存存储的锁与此时的锁key的值不一样时，机器A加锁失败；
	5、当机器B再次判断内存存储的锁与此时的锁key的值一样，机器B加锁成功。
	
	
	适用场景：
	如果为了效率而适用分布式锁，且偶尔允许失败，可以使用单节点redis分布式锁；如果为了正确性而使用分布式锁，
	最好再次检查redis分布式锁，虽然性能降低了，但是正确率更高
	
	现有框架： Redisson,spring-integration-redis
	
	
三.基于zookeeper实现分布式锁
   
   优点：稳定性好，ZAB一致性算法实现
   缺点：效率比redis低一些
   框架：Apache Curator
   
   
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
